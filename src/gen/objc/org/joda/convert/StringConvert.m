//
//  Generated by the J2ObjC translator.  DO NOT EDIT!
//  source: /Users/marcussmith/temp/joda-convert/src/main/java/org/joda/convert/StringConvert.java
//

#include "IOSClass.h"
#include "IOSObjectArray.h"
#include "J2ObjC_source.h"
#include "java/lang/Boolean.h"
#include "java/lang/Byte.h"
#include "java/lang/CharSequence.h"
#include "java/lang/Character.h"
#include "java/lang/ClassLoader.h"
#include "java/lang/Double.h"
#include "java/lang/Exception.h"
#include "java/lang/Float.h"
#include "java/lang/IllegalArgumentException.h"
#include "java/lang/IllegalStateException.h"
#include "java/lang/Integer.h"
#include "java/lang/Long.h"
#include "java/lang/NoSuchMethodException.h"
#include "java/lang/Short.h"
#include "java/lang/reflect/Constructor.h"
#include "java/lang/reflect/Method.h"
#include "java/lang/reflect/Modifier.h"
#include "java/util/concurrent/ConcurrentHashMap.h"
#include "java/util/concurrent/ConcurrentMap.h"
#include "org/joda/convert/FromString.h"
#include "org/joda/convert/JDKStringConverter.h"
#include "org/joda/convert/MethodConstructorStringConverter.h"
#include "org/joda/convert/MethodsStringConverter.h"
#include "org/joda/convert/StringConvert.h"
#include "org/joda/convert/StringConverter.h"
#include "org/joda/convert/ToString.h"

@interface OrgJodaConvertStringConvert () {
 @public
  id<JavaUtilConcurrentConcurrentMap> registered_;
}

- (void)tryRegisterWithNSString:(NSString *)className_
                   withNSString:(NSString *)fromStringMethodName;

- (id<OrgJodaConvertStringConverter>)findAnnotationConverterWithIOSClass:(IOSClass *)cls;

- (JavaLangReflectMethod *)findToStringMethodWithIOSClass:(IOSClass *)cls;

- (JavaLangReflectConstructor *)findFromStringConstructorWithIOSClass:(IOSClass *)cls;

- (JavaLangReflectMethod *)findFromStringMethodWithIOSClass:(IOSClass *)cls
                                                withBoolean:(jboolean)searchSuperclasses;

- (JavaLangReflectMethod *)findToStringMethodWithIOSClass:(IOSClass *)cls
                                             withNSString:(NSString *)methodName;

- (JavaLangReflectMethod *)findFromStringMethodWithIOSClass:(IOSClass *)cls
                                               withNSString:(NSString *)methodName;

- (JavaLangReflectConstructor *)findFromStringConstructorByTypeWithIOSClass:(IOSClass *)cls;

@end

J2OBJC_FIELD_SETTER(OrgJodaConvertStringConvert, registered_, id<JavaUtilConcurrentConcurrentMap>)

__attribute__((unused)) static void OrgJodaConvertStringConvert_tryRegisterWithNSString_withNSString_(OrgJodaConvertStringConvert *self, NSString *className_, NSString *fromStringMethodName);

__attribute__((unused)) static id<OrgJodaConvertStringConverter> OrgJodaConvertStringConvert_findAnnotationConverterWithIOSClass_(OrgJodaConvertStringConvert *self, IOSClass *cls);

__attribute__((unused)) static JavaLangReflectMethod *OrgJodaConvertStringConvert_findToStringMethodWithIOSClass_(OrgJodaConvertStringConvert *self, IOSClass *cls);

__attribute__((unused)) static JavaLangReflectConstructor *OrgJodaConvertStringConvert_findFromStringConstructorWithIOSClass_(OrgJodaConvertStringConvert *self, IOSClass *cls);

__attribute__((unused)) static JavaLangReflectMethod *OrgJodaConvertStringConvert_findFromStringMethodWithIOSClass_withBoolean_(OrgJodaConvertStringConvert *self, IOSClass *cls, jboolean searchSuperclasses);

__attribute__((unused)) static JavaLangReflectMethod *OrgJodaConvertStringConvert_findToStringMethodWithIOSClass_withNSString_(OrgJodaConvertStringConvert *self, IOSClass *cls, NSString *methodName);

__attribute__((unused)) static JavaLangReflectMethod *OrgJodaConvertStringConvert_findFromStringMethodWithIOSClass_withNSString_(OrgJodaConvertStringConvert *self, IOSClass *cls, NSString *methodName);

__attribute__((unused)) static JavaLangReflectConstructor *OrgJodaConvertStringConvert_findFromStringConstructorByTypeWithIOSClass_(OrgJodaConvertStringConvert *self, IOSClass *cls);

J2OBJC_INITIALIZED_DEFN(OrgJodaConvertStringConvert)

OrgJodaConvertStringConvert *OrgJodaConvertStringConvert_INSTANCE;

@implementation OrgJodaConvertStringConvert

J2OBJC_IGNORE_DESIGNATED_BEGIN
- (instancetype __nonnull)init {
  OrgJodaConvertStringConvert_init(self);
  return self;
}
J2OBJC_IGNORE_DESIGNATED_END

- (instancetype __nonnull)initWithBoolean:(jboolean)includeJdkConverters {
  OrgJodaConvertStringConvert_initWithBoolean_(self, includeJdkConverters);
  return self;
}

- (void)tryRegisterWithNSString:(NSString *)className_
                   withNSString:(NSString *)fromStringMethodName {
  OrgJodaConvertStringConvert_tryRegisterWithNSString_withNSString_(self, className_, fromStringMethodName);
}

- (NSString *)convertToStringWithId:(id)object {
  if (object == nil) {
    return nil;
  }
  IOSClass *cls = [object java_getClass];
  id<OrgJodaConvertStringConverter> conv = [self findConverterWithIOSClass:cls];
  return [((id<OrgJodaConvertStringConverter>) nil_chk(conv)) convertToStringWithId:object];
}

- (NSString *)convertToStringWithIOSClass:(IOSClass *)cls
                                   withId:(id)object {
  if (object == nil) {
    return nil;
  }
  id<OrgJodaConvertStringConverter> conv = [self findConverterWithIOSClass:cls];
  return [((id<OrgJodaConvertStringConverter>) nil_chk(conv)) convertToStringWithId:object];
}

- (id)convertFromStringWithIOSClass:(IOSClass *)cls
                       withNSString:(NSString *)str {
  if (str == nil) {
    return nil;
  }
  id<OrgJodaConvertStringConverter> conv = [self findConverterWithIOSClass:cls];
  return [((id<OrgJodaConvertStringConverter>) nil_chk(conv)) convertFromStringWithIOSClass:cls withNSString:str];
}

- (id<OrgJodaConvertStringConverter>)findConverterWithIOSClass:(IOSClass *)cls {
  if (cls == nil) {
    @throw create_JavaLangIllegalArgumentException_initWithNSString_(@"Class must not be null");
  }
  id<OrgJodaConvertStringConverter> conv = [((id<JavaUtilConcurrentConcurrentMap>) nil_chk(registered_)) getWithId:cls];
  if (conv == nil) {
    if (cls == NSObject_class_()) {
      @throw create_JavaLangIllegalStateException_initWithNSString_(JreStrcat("$@", @"No registered converter found: ", cls));
    }
    IOSClass *loopCls = [cls getSuperclass];
    while (loopCls != nil && conv == nil) {
      conv = [registered_ getWithId:loopCls];
      loopCls = [loopCls getSuperclass];
    }
    if (conv == nil) {
      conv = OrgJodaConvertStringConvert_findAnnotationConverterWithIOSClass_(self, cls);
      if (conv == nil) {
        @throw create_JavaLangIllegalStateException_initWithNSString_(JreStrcat("$@", @"No registered converter found: ", cls));
      }
    }
    [registered_ putIfAbsentWithId:cls withId:conv];
  }
  return conv;
}

- (id<OrgJodaConvertStringConverter>)findAnnotationConverterWithIOSClass:(IOSClass *)cls {
  return OrgJodaConvertStringConvert_findAnnotationConverterWithIOSClass_(self, cls);
}

- (JavaLangReflectMethod *)findToStringMethodWithIOSClass:(IOSClass *)cls {
  return OrgJodaConvertStringConvert_findToStringMethodWithIOSClass_(self, cls);
}

- (JavaLangReflectConstructor *)findFromStringConstructorWithIOSClass:(IOSClass *)cls {
  return OrgJodaConvertStringConvert_findFromStringConstructorWithIOSClass_(self, cls);
}

- (JavaLangReflectMethod *)findFromStringMethodWithIOSClass:(IOSClass *)cls
                                                withBoolean:(jboolean)searchSuperclasses {
  return OrgJodaConvertStringConvert_findFromStringMethodWithIOSClass_withBoolean_(self, cls, searchSuperclasses);
}

- (void)register__WithIOSClass:(IOSClass *)cls
withOrgJodaConvertStringConverter:(id<OrgJodaConvertStringConverter>)converter {
  if (cls == nil) {
    @throw create_JavaLangIllegalArgumentException_initWithNSString_(@"Class must not be null");
  }
  if (converter == nil) {
    @throw create_JavaLangIllegalArgumentException_initWithNSString_(@"StringConverter must not be null");
  }
  if (self == OrgJodaConvertStringConvert_INSTANCE) {
    @throw create_JavaLangIllegalStateException_initWithNSString_(@"Global singleton cannot be extended");
  }
  id<OrgJodaConvertStringConverter> old = [((id<JavaUtilConcurrentConcurrentMap>) nil_chk(registered_)) putIfAbsentWithId:cls withId:converter];
  if (old != nil) {
    @throw create_JavaLangIllegalStateException_initWithNSString_(JreStrcat("$@", @"Converter already registered for class: ", cls));
  }
}

- (void)registerMethodsWithIOSClass:(IOSClass *)cls
                       withNSString:(NSString *)toStringMethodName
                       withNSString:(NSString *)fromStringMethodName {
  if (cls == nil) {
    @throw create_JavaLangIllegalArgumentException_initWithNSString_(@"Class must not be null");
  }
  if (toStringMethodName == nil || fromStringMethodName == nil) {
    @throw create_JavaLangIllegalArgumentException_initWithNSString_(@"Method names must not be null");
  }
  if (self == OrgJodaConvertStringConvert_INSTANCE) {
    @throw create_JavaLangIllegalStateException_initWithNSString_(@"Global singleton cannot be extended");
  }
  JavaLangReflectMethod *toString = OrgJodaConvertStringConvert_findToStringMethodWithIOSClass_withNSString_(self, cls, toStringMethodName);
  JavaLangReflectMethod *fromString = OrgJodaConvertStringConvert_findFromStringMethodWithIOSClass_withNSString_(self, cls, fromStringMethodName);
  OrgJodaConvertMethodsStringConverter *converter = create_OrgJodaConvertMethodsStringConverter_initWithIOSClass_withJavaLangReflectMethod_withJavaLangReflectMethod_(cls, toString, fromString);
  id<OrgJodaConvertStringConverter> old = [((id<JavaUtilConcurrentConcurrentMap>) nil_chk(registered_)) putIfAbsentWithId:cls withId:converter];
  if (old != nil) {
    @throw create_JavaLangIllegalStateException_initWithNSString_(JreStrcat("$@", @"Converter already registered for class: ", cls));
  }
}

- (void)registerMethodConstructorWithIOSClass:(IOSClass *)cls
                                 withNSString:(NSString *)toStringMethodName {
  if (cls == nil) {
    @throw create_JavaLangIllegalArgumentException_initWithNSString_(@"Class must not be null");
  }
  if (toStringMethodName == nil) {
    @throw create_JavaLangIllegalArgumentException_initWithNSString_(@"Method name must not be null");
  }
  if (self == OrgJodaConvertStringConvert_INSTANCE) {
    @throw create_JavaLangIllegalStateException_initWithNSString_(@"Global singleton cannot be extended");
  }
  JavaLangReflectMethod *toString = OrgJodaConvertStringConvert_findToStringMethodWithIOSClass_withNSString_(self, cls, toStringMethodName);
  JavaLangReflectConstructor *fromString = OrgJodaConvertStringConvert_findFromStringConstructorByTypeWithIOSClass_(self, cls);
  OrgJodaConvertMethodConstructorStringConverter *converter = create_OrgJodaConvertMethodConstructorStringConverter_initWithIOSClass_withJavaLangReflectMethod_withJavaLangReflectConstructor_(cls, toString, fromString);
  id<OrgJodaConvertStringConverter> old = [((id<JavaUtilConcurrentConcurrentMap>) nil_chk(registered_)) putIfAbsentWithId:cls withId:converter];
  if (old != nil) {
    @throw create_JavaLangIllegalStateException_initWithNSString_(JreStrcat("$@", @"Converter already registered for class: ", cls));
  }
}

- (JavaLangReflectMethod *)findToStringMethodWithIOSClass:(IOSClass *)cls
                                             withNSString:(NSString *)methodName {
  return OrgJodaConvertStringConvert_findToStringMethodWithIOSClass_withNSString_(self, cls, methodName);
}

- (JavaLangReflectMethod *)findFromStringMethodWithIOSClass:(IOSClass *)cls
                                               withNSString:(NSString *)methodName {
  return OrgJodaConvertStringConvert_findFromStringMethodWithIOSClass_withNSString_(self, cls, methodName);
}

- (JavaLangReflectConstructor *)findFromStringConstructorByTypeWithIOSClass:(IOSClass *)cls {
  return OrgJodaConvertStringConvert_findFromStringConstructorByTypeWithIOSClass_(self, cls);
}

- (NSString *)description {
  return [[self java_getClass] getSimpleName];
}

- (void)dealloc {
  RELEASE_(registered_);
  [super dealloc];
}

+ (const J2ObjcClassInfo *)__metadata {
  static J2ObjcMethodInfo methods[] = {
    { NULL, NULL, 0x1, -1, -1, -1, -1, -1, -1 },
    { NULL, NULL, 0x1, -1, 0, -1, -1, -1, -1 },
    { NULL, "V", 0x2, 1, 2, -1, -1, -1, -1 },
    { NULL, "LNSString;", 0x1, 3, 4, -1, 5, -1, -1 },
    { NULL, "LNSString;", 0x1, 3, 6, -1, 7, -1, -1 },
    { NULL, "LNSObject;", 0x1, 8, 9, -1, 10, -1, -1 },
    { NULL, "LOrgJodaConvertStringConverter;", 0x1, 11, 12, -1, 13, -1, -1 },
    { NULL, "LOrgJodaConvertStringConverter;", 0x2, 14, 12, -1, 13, -1, -1 },
    { NULL, "LJavaLangReflectMethod;", 0x2, 15, 12, -1, 16, -1, -1 },
    { NULL, "LJavaLangReflectConstructor;", 0x2, 17, 12, -1, 18, -1, -1 },
    { NULL, "LJavaLangReflectMethod;", 0x2, 19, 20, -1, 21, -1, -1 },
    { NULL, "V", 0x1, 22, 23, -1, 24, -1, -1 },
    { NULL, "V", 0x1, 25, 26, -1, 27, -1, -1 },
    { NULL, "V", 0x1, 28, 9, -1, 29, -1, -1 },
    { NULL, "LJavaLangReflectMethod;", 0x2, 15, 9, -1, 30, -1, -1 },
    { NULL, "LJavaLangReflectMethod;", 0x2, 19, 9, -1, 30, -1, -1 },
    { NULL, "LJavaLangReflectConstructor;", 0x2, 31, 12, -1, 18, -1, -1 },
    { NULL, "LNSString;", 0x1, 32, -1, -1, -1, -1, -1 },
  };
  #pragma clang diagnostic push
  #pragma clang diagnostic ignored "-Wobjc-multiple-method-names"
  #pragma clang diagnostic ignored "-Wundeclared-selector"
  methods[0].selector = @selector(init);
  methods[1].selector = @selector(initWithBoolean:);
  methods[2].selector = @selector(tryRegisterWithNSString:withNSString:);
  methods[3].selector = @selector(convertToStringWithId:);
  methods[4].selector = @selector(convertToStringWithIOSClass:withId:);
  methods[5].selector = @selector(convertFromStringWithIOSClass:withNSString:);
  methods[6].selector = @selector(findConverterWithIOSClass:);
  methods[7].selector = @selector(findAnnotationConverterWithIOSClass:);
  methods[8].selector = @selector(findToStringMethodWithIOSClass:);
  methods[9].selector = @selector(findFromStringConstructorWithIOSClass:);
  methods[10].selector = @selector(findFromStringMethodWithIOSClass:withBoolean:);
  methods[11].selector = @selector(register__WithIOSClass:withOrgJodaConvertStringConverter:);
  methods[12].selector = @selector(registerMethodsWithIOSClass:withNSString:withNSString:);
  methods[13].selector = @selector(registerMethodConstructorWithIOSClass:withNSString:);
  methods[14].selector = @selector(findToStringMethodWithIOSClass:withNSString:);
  methods[15].selector = @selector(findFromStringMethodWithIOSClass:withNSString:);
  methods[16].selector = @selector(findFromStringConstructorByTypeWithIOSClass:);
  methods[17].selector = @selector(description);
  #pragma clang diagnostic pop
  static const J2ObjcFieldInfo fields[] = {
    { "INSTANCE", "LOrgJodaConvertStringConvert;", .constantValue.asLong = 0, 0x19, -1, 33, -1, -1 },
    { "registered_", "LJavaUtilConcurrentConcurrentMap;", .constantValue.asLong = 0, 0x12, -1, -1, 34, -1 },
  };
  static const void *ptrTable[] = { "Z", "tryRegister", "LNSString;LNSString;", "convertToString", "LNSObject;", "<T:Ljava/lang/Object;>(TT;)Ljava/lang/String;", "LIOSClass;LNSObject;", "<T:Ljava/lang/Object;>(Ljava/lang/Class<TT;>;TT;)Ljava/lang/String;", "convertFromString", "LIOSClass;LNSString;", "<T:Ljava/lang/Object;>(Ljava/lang/Class<TT;>;Ljava/lang/String;)TT;", "findConverter", "LIOSClass;", "<T:Ljava/lang/Object;>(Ljava/lang/Class<TT;>;)Lorg/joda/convert/StringConverter<TT;>;", "findAnnotationConverter", "findToStringMethod", "(Ljava/lang/Class<*>;)Ljava/lang/reflect/Method;", "findFromStringConstructor", "<T:Ljava/lang/Object;>(Ljava/lang/Class<TT;>;)Ljava/lang/reflect/Constructor<TT;>;", "findFromStringMethod", "LIOSClass;Z", "(Ljava/lang/Class<*>;Z)Ljava/lang/reflect/Method;", "register", "LIOSClass;LOrgJodaConvertStringConverter;", "<T:Ljava/lang/Object;>(Ljava/lang/Class<TT;>;Lorg/joda/convert/StringConverter<TT;>;)V", "registerMethods", "LIOSClass;LNSString;LNSString;", "<T:Ljava/lang/Object;>(Ljava/lang/Class<TT;>;Ljava/lang/String;Ljava/lang/String;)V", "registerMethodConstructor", "<T:Ljava/lang/Object;>(Ljava/lang/Class<TT;>;Ljava/lang/String;)V", "(Ljava/lang/Class<*>;Ljava/lang/String;)Ljava/lang/reflect/Method;", "findFromStringConstructorByType", "toString", &OrgJodaConvertStringConvert_INSTANCE, "Ljava/util/concurrent/ConcurrentMap<Ljava/lang/Class<*>;Lorg/joda/convert/StringConverter<*>;>;" };
  static const J2ObjcClassInfo _OrgJodaConvertStringConvert = { "StringConvert", "org.joda.convert", ptrTable, methods, fields, 7, 0x11, 18, 2, -1, -1, -1, -1, -1 };
  return &_OrgJodaConvertStringConvert;
}

+ (void)initialize {
  if (self == [OrgJodaConvertStringConvert class]) {
    JreStrongAssignAndConsume(&OrgJodaConvertStringConvert_INSTANCE, new_OrgJodaConvertStringConvert_init());
    J2OBJC_SET_INITIALIZED(OrgJodaConvertStringConvert)
  }
}

@end

void OrgJodaConvertStringConvert_init(OrgJodaConvertStringConvert *self) {
  OrgJodaConvertStringConvert_initWithBoolean_(self, true);
}

OrgJodaConvertStringConvert *new_OrgJodaConvertStringConvert_init() {
  J2OBJC_NEW_IMPL(OrgJodaConvertStringConvert, init)
}

OrgJodaConvertStringConvert *create_OrgJodaConvertStringConvert_init() {
  J2OBJC_CREATE_IMPL(OrgJodaConvertStringConvert, init)
}

void OrgJodaConvertStringConvert_initWithBoolean_(OrgJodaConvertStringConvert *self, jboolean includeJdkConverters) {
  NSObject_init(self);
  JreStrongAssignAndConsume(&self->registered_, new_JavaUtilConcurrentConcurrentHashMap_init());
  if (includeJdkConverters) {
    {
      IOSObjectArray *a__ = OrgJodaConvertJDKStringConverter_values();
      OrgJodaConvertJDKStringConverter * const *b__ = ((IOSObjectArray *) nil_chk(a__))->buffer_;
      OrgJodaConvertJDKStringConverter * const *e__ = b__ + a__->size_;
      while (b__ < e__) {
        OrgJodaConvertJDKStringConverter *conv = *b__++;
        [self->registered_ putWithId:[((OrgJodaConvertJDKStringConverter *) nil_chk(conv)) getType] withId:conv];
      }
    }
    [self->registered_ putWithId:JreLoadStatic(JavaLangBoolean, TYPE) withId:JreLoadEnum(OrgJodaConvertJDKStringConverter, BOOLEAN)];
    [self->registered_ putWithId:JreLoadStatic(JavaLangByte, TYPE) withId:JreLoadEnum(OrgJodaConvertJDKStringConverter, BYTE)];
    [self->registered_ putWithId:JreLoadStatic(JavaLangShort, TYPE) withId:JreLoadEnum(OrgJodaConvertJDKStringConverter, SHORT)];
    [self->registered_ putWithId:JreLoadStatic(JavaLangInteger, TYPE) withId:JreLoadEnum(OrgJodaConvertJDKStringConverter, INTEGER)];
    [self->registered_ putWithId:JreLoadStatic(JavaLangLong, TYPE) withId:JreLoadEnum(OrgJodaConvertJDKStringConverter, LONG)];
    [self->registered_ putWithId:JreLoadStatic(JavaLangFloat, TYPE) withId:JreLoadEnum(OrgJodaConvertJDKStringConverter, FLOAT)];
    [self->registered_ putWithId:JreLoadStatic(JavaLangDouble, TYPE) withId:JreLoadEnum(OrgJodaConvertJDKStringConverter, DOUBLE)];
    [self->registered_ putWithId:JreLoadStatic(JavaLangCharacter, TYPE) withId:JreLoadEnum(OrgJodaConvertJDKStringConverter, CHARACTER)];
    OrgJodaConvertStringConvert_tryRegisterWithNSString_withNSString_(self, @"javax.time.Instant", @"parse");
    OrgJodaConvertStringConvert_tryRegisterWithNSString_withNSString_(self, @"javax.time.Duration", @"parse");
    OrgJodaConvertStringConvert_tryRegisterWithNSString_withNSString_(self, @"javax.time.calendar.LocalDate", @"parse");
    OrgJodaConvertStringConvert_tryRegisterWithNSString_withNSString_(self, @"javax.time.calendar.LocalTime", @"parse");
    OrgJodaConvertStringConvert_tryRegisterWithNSString_withNSString_(self, @"javax.time.calendar.LocalDateTime", @"parse");
    OrgJodaConvertStringConvert_tryRegisterWithNSString_withNSString_(self, @"javax.time.calendar.OffsetDate", @"parse");
    OrgJodaConvertStringConvert_tryRegisterWithNSString_withNSString_(self, @"javax.time.calendar.OffsetTime", @"parse");
    OrgJodaConvertStringConvert_tryRegisterWithNSString_withNSString_(self, @"javax.time.calendar.OffsetDateTime", @"parse");
    OrgJodaConvertStringConvert_tryRegisterWithNSString_withNSString_(self, @"javax.time.calendar.ZonedDateTime", @"parse");
    OrgJodaConvertStringConvert_tryRegisterWithNSString_withNSString_(self, @"javax.time.calendar.Year", @"parse");
    OrgJodaConvertStringConvert_tryRegisterWithNSString_withNSString_(self, @"javax.time.calendar.YearMonth", @"parse");
    OrgJodaConvertStringConvert_tryRegisterWithNSString_withNSString_(self, @"javax.time.calendar.MonthDay", @"parse");
    OrgJodaConvertStringConvert_tryRegisterWithNSString_withNSString_(self, @"javax.time.calendar.Period", @"parse");
    OrgJodaConvertStringConvert_tryRegisterWithNSString_withNSString_(self, @"javax.time.calendar.ZoneOffset", @"of");
    OrgJodaConvertStringConvert_tryRegisterWithNSString_withNSString_(self, @"javax.time.calendar.ZoneId", @"of");
    OrgJodaConvertStringConvert_tryRegisterWithNSString_withNSString_(self, @"javax.time.calendar.TimeZone", @"of");
  }
}

OrgJodaConvertStringConvert *new_OrgJodaConvertStringConvert_initWithBoolean_(jboolean includeJdkConverters) {
  J2OBJC_NEW_IMPL(OrgJodaConvertStringConvert, initWithBoolean_, includeJdkConverters)
}

OrgJodaConvertStringConvert *create_OrgJodaConvertStringConvert_initWithBoolean_(jboolean includeJdkConverters) {
  J2OBJC_CREATE_IMPL(OrgJodaConvertStringConvert, initWithBoolean_, includeJdkConverters)
}

void OrgJodaConvertStringConvert_tryRegisterWithNSString_withNSString_(OrgJodaConvertStringConvert *self, NSString *className_, NSString *fromStringMethodName) {
  @try {
    IOSClass *cls = [((JavaLangClassLoader *) nil_chk([[self java_getClass] getClassLoader])) loadClassWithNSString:className_];
    [self registerMethodsWithIOSClass:cls withNSString:@"toString" withNSString:fromStringMethodName];
  }
  @catch (JavaLangException *ex) {
  }
}

id<OrgJodaConvertStringConverter> OrgJodaConvertStringConvert_findAnnotationConverterWithIOSClass_(OrgJodaConvertStringConvert *self, IOSClass *cls) {
  JavaLangReflectMethod *toString = OrgJodaConvertStringConvert_findToStringMethodWithIOSClass_(self, cls);
  if (toString == nil) {
    return nil;
  }
  JavaLangReflectConstructor *con = OrgJodaConvertStringConvert_findFromStringConstructorWithIOSClass_(self, cls);
  JavaLangReflectMethod *fromString = OrgJodaConvertStringConvert_findFromStringMethodWithIOSClass_withBoolean_(self, cls, con == nil);
  if (con == nil && fromString == nil) {
    @throw create_JavaLangIllegalStateException_initWithNSString_(@"Class annotated with @ToString but not with @FromString");
  }
  if (con != nil && fromString != nil) {
    @throw create_JavaLangIllegalStateException_initWithNSString_(@"Both method and constructor are annotated with @FromString");
  }
  if (con != nil) {
    return create_OrgJodaConvertMethodConstructorStringConverter_initWithIOSClass_withJavaLangReflectMethod_withJavaLangReflectConstructor_(cls, toString, con);
  }
  else {
    return create_OrgJodaConvertMethodsStringConverter_initWithIOSClass_withJavaLangReflectMethod_withJavaLangReflectMethod_(cls, toString, fromString);
  }
}

JavaLangReflectMethod *OrgJodaConvertStringConvert_findToStringMethodWithIOSClass_(OrgJodaConvertStringConvert *self, IOSClass *cls) {
  JavaLangReflectMethod *matched = nil;
  IOSClass *loopCls = cls;
  while (loopCls != nil && matched == nil) {
    IOSObjectArray *methods = [loopCls getDeclaredMethods];
    {
      IOSObjectArray *a__ = methods;
      JavaLangReflectMethod * const *b__ = ((IOSObjectArray *) nil_chk(a__))->buffer_;
      JavaLangReflectMethod * const *e__ = b__ + a__->size_;
      while (b__ < e__) {
        JavaLangReflectMethod *method = *b__++;
        id<OrgJodaConvertToString> toString = ((id<OrgJodaConvertToString>) [((JavaLangReflectMethod *) nil_chk(method)) getAnnotationWithIOSClass:OrgJodaConvertToString_class_()]);
        if (toString != nil) {
          if (matched != nil) {
            @throw create_JavaLangIllegalStateException_initWithNSString_(@"Two methods are annotated with @ToString");
          }
          matched = method;
        }
      }
    }
    loopCls = [loopCls getSuperclass];
  }
  return matched;
}

JavaLangReflectConstructor *OrgJodaConvertStringConvert_findFromStringConstructorWithIOSClass_(OrgJodaConvertStringConvert *self, IOSClass *cls) {
  JavaLangReflectConstructor *con;
  @try {
    con = [((IOSClass *) nil_chk(cls)) getDeclaredConstructor:[IOSObjectArray arrayWithObjects:(id[]){ NSString_class_() } count:1 type:IOSClass_class_()]];
  }
  @catch (JavaLangNoSuchMethodException *ex) {
    @try {
      con = [cls getDeclaredConstructor:[IOSObjectArray arrayWithObjects:(id[]){ JavaLangCharSequence_class_() } count:1 type:IOSClass_class_()]];
    }
    @catch (JavaLangNoSuchMethodException *ex2) {
      return nil;
    }
  }
  id<OrgJodaConvertFromString> fromString = ((id<OrgJodaConvertFromString>) [((JavaLangReflectConstructor *) nil_chk(con)) getAnnotationWithIOSClass:OrgJodaConvertFromString_class_()]);
  return fromString != nil ? con : nil;
}

JavaLangReflectMethod *OrgJodaConvertStringConvert_findFromStringMethodWithIOSClass_withBoolean_(OrgJodaConvertStringConvert *self, IOSClass *cls, jboolean searchSuperclasses) {
  JavaLangReflectMethod *matched = nil;
  IOSClass *loopCls = cls;
  while (loopCls != nil && matched == nil) {
    IOSObjectArray *methods = [loopCls getDeclaredMethods];
    {
      IOSObjectArray *a__ = methods;
      JavaLangReflectMethod * const *b__ = ((IOSObjectArray *) nil_chk(a__))->buffer_;
      JavaLangReflectMethod * const *e__ = b__ + a__->size_;
      while (b__ < e__) {
        JavaLangReflectMethod *method = *b__++;
        id<OrgJodaConvertFromString> fromString = ((id<OrgJodaConvertFromString>) [((JavaLangReflectMethod *) nil_chk(method)) getAnnotationWithIOSClass:OrgJodaConvertFromString_class_()]);
        if (fromString != nil) {
          if (matched != nil) {
            @throw create_JavaLangIllegalStateException_initWithNSString_(@"Two methods are annotated with @ToString");
          }
          matched = method;
        }
      }
    }
    if (searchSuperclasses == false) {
      break;
    }
    loopCls = [loopCls getSuperclass];
  }
  return matched;
}

JavaLangReflectMethod *OrgJodaConvertStringConvert_findToStringMethodWithIOSClass_withNSString_(OrgJodaConvertStringConvert *self, IOSClass *cls, NSString *methodName) {
  JavaLangReflectMethod *m;
  @try {
    m = [((IOSClass *) nil_chk(cls)) getMethod:methodName parameterTypes:[IOSObjectArray arrayWithLength:0 type:IOSClass_class_()]];
  }
  @catch (JavaLangNoSuchMethodException *ex) {
    @throw create_JavaLangIllegalArgumentException_initWithJavaLangThrowable_(ex);
  }
  if (JavaLangReflectModifier_isStaticWithInt_([((JavaLangReflectMethod *) nil_chk(m)) getModifiers])) {
    @throw create_JavaLangIllegalArgumentException_initWithNSString_(JreStrcat("$$", @"Method must not be static: ", methodName));
  }
  return m;
}

JavaLangReflectMethod *OrgJodaConvertStringConvert_findFromStringMethodWithIOSClass_withNSString_(OrgJodaConvertStringConvert *self, IOSClass *cls, NSString *methodName) {
  JavaLangReflectMethod *m;
  @try {
    m = [((IOSClass *) nil_chk(cls)) getMethod:methodName parameterTypes:[IOSObjectArray arrayWithObjects:(id[]){ NSString_class_() } count:1 type:IOSClass_class_()]];
  }
  @catch (JavaLangNoSuchMethodException *ex) {
    @try {
      m = [cls getMethod:methodName parameterTypes:[IOSObjectArray arrayWithObjects:(id[]){ JavaLangCharSequence_class_() } count:1 type:IOSClass_class_()]];
    }
    @catch (JavaLangNoSuchMethodException *ex2) {
      @throw create_JavaLangIllegalArgumentException_initWithNSString_withJavaLangThrowable_(@"Method not found", ex2);
    }
  }
  if (JavaLangReflectModifier_isStaticWithInt_([((JavaLangReflectMethod *) nil_chk(m)) getModifiers]) == false) {
    @throw create_JavaLangIllegalArgumentException_initWithNSString_(JreStrcat("$$", @"Method must be static: ", methodName));
  }
  return m;
}

JavaLangReflectConstructor *OrgJodaConvertStringConvert_findFromStringConstructorByTypeWithIOSClass_(OrgJodaConvertStringConvert *self, IOSClass *cls) {
  @try {
    return [((IOSClass *) nil_chk(cls)) getDeclaredConstructor:[IOSObjectArray arrayWithObjects:(id[]){ NSString_class_() } count:1 type:IOSClass_class_()]];
  }
  @catch (JavaLangNoSuchMethodException *ex) {
    @try {
      return [cls getDeclaredConstructor:[IOSObjectArray arrayWithObjects:(id[]){ JavaLangCharSequence_class_() } count:1 type:IOSClass_class_()]];
    }
    @catch (JavaLangNoSuchMethodException *ex2) {
      @throw create_JavaLangIllegalArgumentException_initWithNSString_withJavaLangThrowable_(@"Constructor not found", ex2);
    }
  }
}

J2OBJC_CLASS_TYPE_LITERAL_SOURCE(OrgJodaConvertStringConvert)

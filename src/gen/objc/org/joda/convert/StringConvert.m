//
//  Generated by the J2ObjC translator.  DO NOT EDIT!
//  source: /Users/nbransby/Documents/joda-convert/src/main/java/org/joda/convert/StringConvert.java
//

#include "IOSClass.h"
#include "IOSObjectArray.h"
#include "J2ObjC_source.h"
#include "java/lang/Boolean.h"
#include "java/lang/Byte.h"
#include "java/lang/CharSequence.h"
#include "java/lang/Character.h"
#include "java/lang/ClassLoader.h"
#include "java/lang/Double.h"
#include "java/lang/Exception.h"
#include "java/lang/Float.h"
#include "java/lang/IllegalArgumentException.h"
#include "java/lang/IllegalStateException.h"
#include "java/lang/Integer.h"
#include "java/lang/Long.h"
#include "java/lang/NoSuchMethodException.h"
#include "java/lang/RuntimeException.h"
#include "java/lang/Short.h"
#include "java/lang/reflect/Constructor.h"
#include "java/lang/reflect/Method.h"
#include "java/lang/reflect/Modifier.h"
#include "java/util/Arrays.h"
#include "java/util/List.h"
#include "java/util/concurrent/ConcurrentHashMap.h"
#include "java/util/concurrent/ConcurrentMap.h"
#include "java/util/concurrent/CopyOnWriteArrayList.h"
#include "org/joda/convert/AnnotationStringConverterFactory.h"
#include "org/joda/convert/EnumStringConverterFactory.h"
#include "org/joda/convert/FromStringConverter.h"
#include "org/joda/convert/JDKStringConverter.h"
#include "org/joda/convert/MethodConstructorStringConverter.h"
#include "org/joda/convert/MethodsStringConverter.h"
#include "org/joda/convert/StringConvert.h"
#include "org/joda/convert/StringConverter.h"
#include "org/joda/convert/StringConverterFactory.h"
#include "org/joda/convert/ToStringConverter.h"
#include "org/joda/convert/TypedAdapter.h"
#include "org/joda/convert/TypedStringConverter.h"
#include "org/joda/convert/factory/BooleanArrayStringConverterFactory.h"
#include "org/joda/convert/factory/BooleanObjectArrayStringConverterFactory.h"
#include "org/joda/convert/factory/ByteObjectArrayStringConverterFactory.h"
#include "org/joda/convert/factory/CharObjectArrayStringConverterFactory.h"
#include "org/joda/convert/factory/NumericArrayStringConverterFactory.h"
#include "org/joda/convert/factory/NumericObjectArrayStringConverterFactory.h"

__attribute__((unused)) static void OrgJodaConvertStringConvert_tryRegisterWithNSString_withNSString_(OrgJodaConvertStringConvert *self, NSString *className_, NSString *fromStringMethodName);
__attribute__((unused)) static id<OrgJodaConvertTypedStringConverter> OrgJodaConvertStringConvert_findConverterQuietWithIOSClass_(OrgJodaConvertStringConvert *self, IOSClass *cls);
__attribute__((unused)) static id<OrgJodaConvertTypedStringConverter> OrgJodaConvertStringConvert_findAnyConverterWithIOSClass_(OrgJodaConvertStringConvert *self, IOSClass *cls);
__attribute__((unused)) static JavaLangReflectMethod *OrgJodaConvertStringConvert_findToStringMethodWithIOSClass_withNSString_(OrgJodaConvertStringConvert *self, IOSClass *cls, NSString *methodName);
__attribute__((unused)) static JavaLangReflectMethod *OrgJodaConvertStringConvert_findFromStringMethodWithIOSClass_withNSString_(OrgJodaConvertStringConvert *self, IOSClass *cls, NSString *methodName);
__attribute__((unused)) static JavaLangReflectConstructor *OrgJodaConvertStringConvert_findFromStringConstructorByTypeWithIOSClass_(OrgJodaConvertStringConvert *self, IOSClass *cls);

@interface OrgJodaConvertStringConvert () {
 @public
  /**
   @brief The list of factories.
   */
  JavaUtilConcurrentCopyOnWriteArrayList *factories_;
  /**
   @brief The cache of converters.
   */
  id<JavaUtilConcurrentConcurrentMap> registered_;
}

/**
 @brief Tries to register a class using the standard toString/parse pattern.
 @param className the class name, not null
 */
- (void)tryRegisterWithNSString:(NSString *)className_
                   withNSString:(NSString *)fromStringMethodName;

/**
 @brief Finds a converter searching registered and annotated.
 @param < T > the type of the converter
 @param cls the class to find a method for, not null
 @return the converter, null if no converter
 @throws RuntimeException if invalid
 */
- (id<OrgJodaConvertTypedStringConverter>)findConverterQuietWithIOSClass:(IOSClass *)cls;

/**
 @brief Finds a converter searching registered and annotated.
 @param < T > the type of the converter
 @param cls the class to find a method for, not null
 @return the converter, not null
 @throws RuntimeException if invalid
 */
- (id<OrgJodaConvertTypedStringConverter>)findAnyConverterWithIOSClass:(IOSClass *)cls;

/**
 @brief Finds the conversion method.
 @param cls the class to find a method for, not null
 @param methodName the name of the method to find, not null
 @return the method to call, null means use <code>toString</code>
 */
- (JavaLangReflectMethod *)findToStringMethodWithIOSClass:(IOSClass *)cls
                                             withNSString:(NSString *)methodName;

/**
 @brief Finds the conversion method.
 @param cls the class to find a method for, not null
 @param methodName the name of the method to find, not null
 @return the method to call, null means use <code>toString</code>
 */
- (JavaLangReflectMethod *)findFromStringMethodWithIOSClass:(IOSClass *)cls
                                               withNSString:(NSString *)methodName;

/**
 @brief Finds the conversion method.
 @param < T > the type of the converter
 @param cls the class to find a method for, not null
 @return the method to call, null means use <code>toString</code>
 */
- (JavaLangReflectConstructor *)findFromStringConstructorByTypeWithIOSClass:(IOSClass *)cls;
@end

J2OBJC_FIELD_SETTER(OrgJodaConvertStringConvert, factories_, JavaUtilConcurrentCopyOnWriteArrayList *)
J2OBJC_FIELD_SETTER(OrgJodaConvertStringConvert, registered_, id<JavaUtilConcurrentConcurrentMap>)

@interface OrgJodaConvertStringConvert_$2 () {
 @public
  id<OrgJodaConvertToStringConverter> val$toString_;
  id<OrgJodaConvertFromStringConverter> val$fromString_;
  IOSClass *val$cls_;
}
@end

J2OBJC_FIELD_SETTER(OrgJodaConvertStringConvert_$2, val$toString_, id<OrgJodaConvertToStringConverter>)
J2OBJC_FIELD_SETTER(OrgJodaConvertStringConvert_$2, val$fromString_, id<OrgJodaConvertFromStringConverter>)
J2OBJC_FIELD_SETTER(OrgJodaConvertStringConvert_$2, val$cls_, IOSClass *)

BOOL OrgJodaConvertStringConvert_initialized = NO;

@implementation OrgJodaConvertStringConvert

OrgJodaConvertStringConvert * OrgJodaConvertStringConvert_INSTANCE_;
id<OrgJodaConvertTypedStringConverter> OrgJodaConvertStringConvert_CACHED_NULL_;

+ (OrgJodaConvertStringConvert *)create {
  return OrgJodaConvertStringConvert_create();
}

- (instancetype)init {
  return [self initOrgJodaConvertStringConvertWithBoolean:YES withOrgJodaConvertStringConverterFactoryArray:[IOSObjectArray arrayWithLength:0 type:OrgJodaConvertStringConverterFactory_class_()]];
}

- (instancetype)initOrgJodaConvertStringConvertWithBoolean:(jboolean)includeJdkConverters
             withOrgJodaConvertStringConverterFactoryArray:(IOSObjectArray *)factories {
  if (self = [super init]) {
    OrgJodaConvertStringConvert_setAndConsume_factories_(self, [[JavaUtilConcurrentCopyOnWriteArrayList alloc] init]);
    OrgJodaConvertStringConvert_setAndConsume_registered_(self, [[JavaUtilConcurrentConcurrentHashMap alloc] init]);
    if (factories == nil) {
      @throw [[[JavaLangIllegalArgumentException alloc] initWithNSString:@"StringConverterFactory array must not be null"] autorelease];
    }
    for (jint i = 0; i < ((IOSObjectArray *) nil_chk(factories))->size_; i++) {
      if (IOSObjectArray_Get(factories, i) == nil) {
        @throw [[[JavaLangIllegalArgumentException alloc] initWithNSString:@"StringConverterFactory array must not contain a null element"] autorelease];
      }
    }
    if (includeJdkConverters) {
      {
        IOSObjectArray *a__ = OrgJodaConvertJDKStringConverterEnum_values();
        OrgJodaConvertJDKStringConverterEnum * const *b__ = ((IOSObjectArray *) nil_chk(a__))->buffer_;
        OrgJodaConvertJDKStringConverterEnum * const *e__ = b__ + a__->size_;
        while (b__ < e__) {
          OrgJodaConvertJDKStringConverterEnum *conv = *b__++;
          [registered_ putWithId:[((OrgJodaConvertJDKStringConverterEnum *) nil_chk(conv)) getType] withId:conv];
        }
      }
      [registered_ putWithId:JavaLangBoolean_get_TYPE_() withId:OrgJodaConvertJDKStringConverterEnum_get_BOOLEAN()];
      [registered_ putWithId:JavaLangByte_get_TYPE_() withId:OrgJodaConvertJDKStringConverterEnum_get_BYTE()];
      [registered_ putWithId:JavaLangShort_get_TYPE_() withId:OrgJodaConvertJDKStringConverterEnum_get_SHORT()];
      [registered_ putWithId:JavaLangInteger_get_TYPE_() withId:OrgJodaConvertJDKStringConverterEnum_get_INTEGER()];
      [registered_ putWithId:JavaLangLong_get_TYPE_() withId:OrgJodaConvertJDKStringConverterEnum_get_LONG()];
      [registered_ putWithId:JavaLangFloat_get_TYPE_() withId:OrgJodaConvertJDKStringConverterEnum_get_FLOAT()];
      [registered_ putWithId:JavaLangDouble_get_TYPE_() withId:OrgJodaConvertJDKStringConverterEnum_get_DOUBLE()];
      [registered_ putWithId:JavaLangCharacter_get_TYPE_() withId:OrgJodaConvertJDKStringConverterEnum_get_CHARACTER()];
      OrgJodaConvertStringConvert_tryRegisterWithNSString_withNSString_(self, @"java.time.Instant", @"parse");
      OrgJodaConvertStringConvert_tryRegisterWithNSString_withNSString_(self, @"java.time.Duration", @"parse");
      OrgJodaConvertStringConvert_tryRegisterWithNSString_withNSString_(self, @"java.time.LocalDate", @"parse");
      OrgJodaConvertStringConvert_tryRegisterWithNSString_withNSString_(self, @"java.time.LocalTime", @"parse");
      OrgJodaConvertStringConvert_tryRegisterWithNSString_withNSString_(self, @"java.time.LocalDateTime", @"parse");
      OrgJodaConvertStringConvert_tryRegisterWithNSString_withNSString_(self, @"java.time.OffsetTime", @"parse");
      OrgJodaConvertStringConvert_tryRegisterWithNSString_withNSString_(self, @"java.time.OffsetDateTime", @"parse");
      OrgJodaConvertStringConvert_tryRegisterWithNSString_withNSString_(self, @"java.time.ZonedDateTime", @"parse");
      OrgJodaConvertStringConvert_tryRegisterWithNSString_withNSString_(self, @"java.time.Year", @"parse");
      OrgJodaConvertStringConvert_tryRegisterWithNSString_withNSString_(self, @"java.time.YearMonth", @"parse");
      OrgJodaConvertStringConvert_tryRegisterWithNSString_withNSString_(self, @"java.time.MonthDay", @"parse");
      OrgJodaConvertStringConvert_tryRegisterWithNSString_withNSString_(self, @"java.time.Period", @"parse");
      OrgJodaConvertStringConvert_tryRegisterWithNSString_withNSString_(self, @"java.time.ZoneOffset", @"of");
      OrgJodaConvertStringConvert_tryRegisterWithNSString_withNSString_(self, @"java.time.ZoneId", @"of");
      OrgJodaConvertStringConvert_tryRegisterWithNSString_withNSString_(self, @"org.threeten.bp.Instant", @"parse");
      OrgJodaConvertStringConvert_tryRegisterWithNSString_withNSString_(self, @"org.threeten.bp.Duration", @"parse");
      OrgJodaConvertStringConvert_tryRegisterWithNSString_withNSString_(self, @"org.threeten.bp.LocalDate", @"parse");
      OrgJodaConvertStringConvert_tryRegisterWithNSString_withNSString_(self, @"org.threeten.bp.LocalTime", @"parse");
      OrgJodaConvertStringConvert_tryRegisterWithNSString_withNSString_(self, @"org.threeten.bp.LocalDateTime", @"parse");
      OrgJodaConvertStringConvert_tryRegisterWithNSString_withNSString_(self, @"org.threeten.bp.OffsetTime", @"parse");
      OrgJodaConvertStringConvert_tryRegisterWithNSString_withNSString_(self, @"org.threeten.bp.OffsetDateTime", @"parse");
      OrgJodaConvertStringConvert_tryRegisterWithNSString_withNSString_(self, @"org.threeten.bp.ZonedDateTime", @"parse");
      OrgJodaConvertStringConvert_tryRegisterWithNSString_withNSString_(self, @"org.threeten.bp.Year", @"parse");
      OrgJodaConvertStringConvert_tryRegisterWithNSString_withNSString_(self, @"org.threeten.bp.YearMonth", @"parse");
      OrgJodaConvertStringConvert_tryRegisterWithNSString_withNSString_(self, @"org.threeten.bp.MonthDay", @"parse");
      OrgJodaConvertStringConvert_tryRegisterWithNSString_withNSString_(self, @"org.threeten.bp.Period", @"parse");
      OrgJodaConvertStringConvert_tryRegisterWithNSString_withNSString_(self, @"org.threeten.bp.ZoneOffset", @"of");
      OrgJodaConvertStringConvert_tryRegisterWithNSString_withNSString_(self, @"org.threeten.bp.ZoneId", @"of");
      OrgJodaConvertStringConvert_tryRegisterWithNSString_withNSString_(self, @"javax.time.Instant", @"parse");
      OrgJodaConvertStringConvert_tryRegisterWithNSString_withNSString_(self, @"javax.time.Duration", @"parse");
      OrgJodaConvertStringConvert_tryRegisterWithNSString_withNSString_(self, @"javax.time.calendar.LocalDate", @"parse");
      OrgJodaConvertStringConvert_tryRegisterWithNSString_withNSString_(self, @"javax.time.calendar.LocalTime", @"parse");
      OrgJodaConvertStringConvert_tryRegisterWithNSString_withNSString_(self, @"javax.time.calendar.LocalDateTime", @"parse");
      OrgJodaConvertStringConvert_tryRegisterWithNSString_withNSString_(self, @"javax.time.calendar.OffsetDate", @"parse");
      OrgJodaConvertStringConvert_tryRegisterWithNSString_withNSString_(self, @"javax.time.calendar.OffsetTime", @"parse");
      OrgJodaConvertStringConvert_tryRegisterWithNSString_withNSString_(self, @"javax.time.calendar.OffsetDateTime", @"parse");
      OrgJodaConvertStringConvert_tryRegisterWithNSString_withNSString_(self, @"javax.time.calendar.ZonedDateTime", @"parse");
      OrgJodaConvertStringConvert_tryRegisterWithNSString_withNSString_(self, @"javax.time.calendar.Year", @"parse");
      OrgJodaConvertStringConvert_tryRegisterWithNSString_withNSString_(self, @"javax.time.calendar.YearMonth", @"parse");
      OrgJodaConvertStringConvert_tryRegisterWithNSString_withNSString_(self, @"javax.time.calendar.MonthDay", @"parse");
      OrgJodaConvertStringConvert_tryRegisterWithNSString_withNSString_(self, @"javax.time.calendar.Period", @"parse");
      OrgJodaConvertStringConvert_tryRegisterWithNSString_withNSString_(self, @"javax.time.calendar.ZoneOffset", @"of");
      OrgJodaConvertStringConvert_tryRegisterWithNSString_withNSString_(self, @"javax.time.calendar.ZoneId", @"of");
      OrgJodaConvertStringConvert_tryRegisterWithNSString_withNSString_(self, @"javax.time.calendar.TimeZone", @"of");
    }
    if (factories->size_ > 0) {
      [self->factories_ addAllWithJavaUtilCollection:JavaUtilArrays_asListWithNSObjectArray_(factories)];
    }
    [self->factories_ addWithId:OrgJodaConvertAnnotationStringConverterFactory_get_INSTANCE_()];
    if (includeJdkConverters) {
      [self->factories_ addWithId:OrgJodaConvertEnumStringConverterFactory_get_INSTANCE_()];
    }
  }
  return self;
}

- (instancetype)initWithBoolean:(jboolean)includeJdkConverters
withOrgJodaConvertStringConverterFactoryArray:(IOSObjectArray *)factories {
  return [self initOrgJodaConvertStringConvertWithBoolean:includeJdkConverters withOrgJodaConvertStringConverterFactoryArray:factories];
}

- (void)tryRegisterWithNSString:(NSString *)className_
                   withNSString:(NSString *)fromStringMethodName {
  OrgJodaConvertStringConvert_tryRegisterWithNSString_withNSString_(self, className_, fromStringMethodName);
}

- (NSString *)convertToStringWithId:(id)object {
  if (object == nil) {
    return nil;
  }
  IOSClass *cls = [nil_chk(object) getClass];
  id<OrgJodaConvertStringConverter> conv = [self findConverterNoGenericsWithIOSClass:cls];
  return [((id<OrgJodaConvertStringConverter>) nil_chk(conv)) convertToStringWithId:object];
}

- (NSString *)convertToStringWithIOSClass:(IOSClass *)cls
                                   withId:(id)object {
  if (object == nil) {
    return nil;
  }
  id<OrgJodaConvertStringConverter> conv = [self findConverterNoGenericsWithIOSClass:cls];
  return [((id<OrgJodaConvertStringConverter>) nil_chk(conv)) convertToStringWithId:object];
}

- (id)convertFromStringWithIOSClass:(IOSClass *)cls
                       withNSString:(NSString *)str {
  if (str == nil) {
    return nil;
  }
  id<OrgJodaConvertStringConverter> conv = [self findConverterWithIOSClass:cls];
  return [((id<OrgJodaConvertStringConverter>) nil_chk(conv)) convertFromStringWithIOSClass:cls withNSString:str];
}

- (jboolean)isConvertibleWithIOSClass:(IOSClass *)cls {
  @try {
    return cls != nil && OrgJodaConvertStringConvert_findConverterQuietWithIOSClass_(self, cls) != nil;
  }
  @catch (JavaLangRuntimeException *ex) {
    return NO;
  }
}

- (id<OrgJodaConvertStringConverter>)findConverterWithIOSClass:(IOSClass *)cls {
  return [self findTypedConverterWithIOSClass:cls];
}

- (id<OrgJodaConvertStringConverter>)findConverterNoGenericsWithIOSClass:(IOSClass *)cls {
  return [self findTypedConverterNoGenericsWithIOSClass:cls];
}

- (id<OrgJodaConvertTypedStringConverter>)findTypedConverterWithIOSClass:(IOSClass *)cls {
  id<OrgJodaConvertTypedStringConverter> conv = OrgJodaConvertStringConvert_findConverterQuietWithIOSClass_(self, cls);
  if (conv == nil) {
    @throw [[[JavaLangIllegalStateException alloc] initWithNSString:JreStrcat("$@", @"No registered converter found: ", cls)] autorelease];
  }
  return conv;
}

- (id<OrgJodaConvertTypedStringConverter>)findTypedConverterNoGenericsWithIOSClass:(IOSClass *)cls {
  id<OrgJodaConvertTypedStringConverter> conv = (id<OrgJodaConvertTypedStringConverter>) check_protocol_cast(OrgJodaConvertStringConvert_findConverterQuietWithIOSClass_(self, cls), @protocol(OrgJodaConvertTypedStringConverter));
  if (conv == nil) {
    @throw [[[JavaLangIllegalStateException alloc] initWithNSString:JreStrcat("$@", @"No registered converter found: ", cls)] autorelease];
  }
  return conv;
}

- (id<OrgJodaConvertTypedStringConverter>)findConverterQuietWithIOSClass:(IOSClass *)cls {
  return OrgJodaConvertStringConvert_findConverterQuietWithIOSClass_(self, cls);
}

- (id<OrgJodaConvertTypedStringConverter>)findAnyConverterWithIOSClass:(IOSClass *)cls {
  return OrgJodaConvertStringConvert_findAnyConverterWithIOSClass_(self, cls);
}

- (void)registerFactoryWithOrgJodaConvertStringConverterFactory:(id<OrgJodaConvertStringConverterFactory>)factory {
  if (factory == nil) {
    @throw [[[JavaLangIllegalArgumentException alloc] initWithNSString:@"Factory must not be null"] autorelease];
  }
  if (self == OrgJodaConvertStringConvert_INSTANCE_) {
    @throw [[[JavaLangIllegalStateException alloc] initWithNSString:@"Global singleton cannot be extended"] autorelease];
  }
  [((JavaUtilConcurrentCopyOnWriteArrayList *) nil_chk(factories_)) addWithInt:0 withId:factory];
}

- (void)register__WithIOSClass:(IOSClass *)cls
withOrgJodaConvertStringConverter:(id<OrgJodaConvertStringConverter>)converter {
  if (cls == nil) {
    @throw [[[JavaLangIllegalArgumentException alloc] initWithNSString:@"Class must not be null"] autorelease];
  }
  if (converter == nil) {
    @throw [[[JavaLangIllegalArgumentException alloc] initWithNSString:@"StringConverter must not be null"] autorelease];
  }
  if (self == OrgJodaConvertStringConvert_INSTANCE_) {
    @throw [[[JavaLangIllegalStateException alloc] initWithNSString:@"Global singleton cannot be extended"] autorelease];
  }
  [((id<JavaUtilConcurrentConcurrentMap>) nil_chk(registered_)) putWithId:cls withId:OrgJodaConvertTypedAdapter_adaptWithIOSClass_withOrgJodaConvertStringConverter_(cls, converter)];
}

- (void)register__WithIOSClass:(IOSClass *)cls
withOrgJodaConvertToStringConverter:(id<OrgJodaConvertToStringConverter>)toString
withOrgJodaConvertFromStringConverter:(id<OrgJodaConvertFromStringConverter>)fromString {
  if (fromString == nil || toString == nil) {
    @throw [[[JavaLangIllegalArgumentException alloc] initWithNSString:@"Converters must not be null"] autorelease];
  }
  [self register__WithIOSClass:cls withOrgJodaConvertStringConverter:[[[OrgJodaConvertStringConvert_$2 alloc] initWithOrgJodaConvertToStringConverter:toString withOrgJodaConvertFromStringConverter:fromString withIOSClass:cls] autorelease]];
}

- (void)registerMethodsWithIOSClass:(IOSClass *)cls
                       withNSString:(NSString *)toStringMethodName
                       withNSString:(NSString *)fromStringMethodName {
  if (cls == nil) {
    @throw [[[JavaLangIllegalArgumentException alloc] initWithNSString:@"Class must not be null"] autorelease];
  }
  if (toStringMethodName == nil || fromStringMethodName == nil) {
    @throw [[[JavaLangIllegalArgumentException alloc] initWithNSString:@"Method names must not be null"] autorelease];
  }
  if (self == OrgJodaConvertStringConvert_INSTANCE_) {
    @throw [[[JavaLangIllegalStateException alloc] initWithNSString:@"Global singleton cannot be extended"] autorelease];
  }
  JavaLangReflectMethod *toString = OrgJodaConvertStringConvert_findToStringMethodWithIOSClass_withNSString_(self, cls, toStringMethodName);
  JavaLangReflectMethod *fromString = OrgJodaConvertStringConvert_findFromStringMethodWithIOSClass_withNSString_(self, cls, fromStringMethodName);
  OrgJodaConvertMethodsStringConverter *converter = [[[OrgJodaConvertMethodsStringConverter alloc] initWithIOSClass:cls withJavaLangReflectMethod:toString withJavaLangReflectMethod:fromString withIOSClass:cls] autorelease];
  [((id<JavaUtilConcurrentConcurrentMap>) nil_chk(registered_)) putIfAbsentWithId:cls withId:converter];
}

- (void)registerMethodConstructorWithIOSClass:(IOSClass *)cls
                                 withNSString:(NSString *)toStringMethodName {
  if (cls == nil) {
    @throw [[[JavaLangIllegalArgumentException alloc] initWithNSString:@"Class must not be null"] autorelease];
  }
  if (toStringMethodName == nil) {
    @throw [[[JavaLangIllegalArgumentException alloc] initWithNSString:@"Method name must not be null"] autorelease];
  }
  if (self == OrgJodaConvertStringConvert_INSTANCE_) {
    @throw [[[JavaLangIllegalStateException alloc] initWithNSString:@"Global singleton cannot be extended"] autorelease];
  }
  JavaLangReflectMethod *toString = OrgJodaConvertStringConvert_findToStringMethodWithIOSClass_withNSString_(self, cls, toStringMethodName);
  JavaLangReflectConstructor *fromString = OrgJodaConvertStringConvert_findFromStringConstructorByTypeWithIOSClass_(self, cls);
  OrgJodaConvertMethodConstructorStringConverter *converter = [[[OrgJodaConvertMethodConstructorStringConverter alloc] initWithIOSClass:cls withJavaLangReflectMethod:toString withJavaLangReflectConstructor:fromString] autorelease];
  [((id<JavaUtilConcurrentConcurrentMap>) nil_chk(registered_)) putIfAbsentWithId:cls withId:converter];
}

- (JavaLangReflectMethod *)findToStringMethodWithIOSClass:(IOSClass *)cls
                                             withNSString:(NSString *)methodName {
  return OrgJodaConvertStringConvert_findToStringMethodWithIOSClass_withNSString_(self, cls, methodName);
}

- (JavaLangReflectMethod *)findFromStringMethodWithIOSClass:(IOSClass *)cls
                                               withNSString:(NSString *)methodName {
  return OrgJodaConvertStringConvert_findFromStringMethodWithIOSClass_withNSString_(self, cls, methodName);
}

- (JavaLangReflectConstructor *)findFromStringConstructorByTypeWithIOSClass:(IOSClass *)cls {
  return OrgJodaConvertStringConvert_findFromStringConstructorByTypeWithIOSClass_(self, cls);
}

- (NSString *)description {
  return [[self getClass] getSimpleName];
}

- (void)dealloc {
  RELEASE_(factories_);
  RELEASE_(registered_);
  [super dealloc];
}

- (void)copyAllFieldsTo:(OrgJodaConvertStringConvert *)other {
  [super copyAllFieldsTo:other];
  OrgJodaConvertStringConvert_set_factories_(other, factories_);
  OrgJodaConvertStringConvert_set_registered_(other, registered_);
}

+ (void)initialize {
  if (self == [OrgJodaConvertStringConvert class]) {
    JreStrongAssignAndConsume(&OrgJodaConvertStringConvert_INSTANCE_, nil, [[OrgJodaConvertStringConvert alloc] init]);
    JreStrongAssignAndConsume(&OrgJodaConvertStringConvert_CACHED_NULL_, nil, [[OrgJodaConvertStringConvert_$1 alloc] init]);
    J2OBJC_SET_INITIALIZED(OrgJodaConvertStringConvert)
  }
}

+ (const J2ObjcClassInfo *)__metadata {
  static const J2ObjcMethodInfo methods[] = {
    { "create", NULL, "Lorg.joda.convert.StringConvert;", 0x9, NULL },
    { "init", "StringConvert", NULL, 0x1, NULL },
    { "initWithBoolean:withOrgJodaConvertStringConverterFactoryArray:", "StringConvert", NULL, 0x81, NULL },
    { "tryRegisterWithNSString:withNSString:", "tryRegister", "V", 0x2, NULL },
    { "convertToStringWithId:", "convertToString", "Ljava.lang.String;", 0x1, NULL },
    { "convertToStringWithIOSClass:withId:", "convertToString", "Ljava.lang.String;", 0x1, NULL },
    { "convertFromStringWithIOSClass:withNSString:", "convertFromString", "TT;", 0x1, NULL },
    { "isConvertibleWithIOSClass:", "isConvertible", "Z", 0x1, NULL },
    { "findConverterWithIOSClass:", "findConverter", "Lorg.joda.convert.StringConverter;", 0x1, NULL },
    { "findConverterNoGenericsWithIOSClass:", "findConverterNoGenerics", "Lorg.joda.convert.StringConverter;", 0x1, NULL },
    { "findTypedConverterWithIOSClass:", "findTypedConverter", "Lorg.joda.convert.TypedStringConverter;", 0x1, NULL },
    { "findTypedConverterNoGenericsWithIOSClass:", "findTypedConverterNoGenerics", "Lorg.joda.convert.TypedStringConverter;", 0x1, NULL },
    { "findConverterQuietWithIOSClass:", "findConverterQuiet", "Lorg.joda.convert.TypedStringConverter;", 0x2, NULL },
    { "findAnyConverterWithIOSClass:", "findAnyConverter", "Lorg.joda.convert.TypedStringConverter;", 0x2, NULL },
    { "registerFactoryWithOrgJodaConvertStringConverterFactory:", "registerFactory", "V", 0x1, NULL },
    { "register__WithIOSClass:withOrgJodaConvertStringConverter:", "register", "V", 0x1, NULL },
    { "register__WithIOSClass:withOrgJodaConvertToStringConverter:withOrgJodaConvertFromStringConverter:", "register", "V", 0x1, NULL },
    { "registerMethodsWithIOSClass:withNSString:withNSString:", "registerMethods", "V", 0x1, NULL },
    { "registerMethodConstructorWithIOSClass:withNSString:", "registerMethodConstructor", "V", 0x1, NULL },
    { "findToStringMethodWithIOSClass:withNSString:", "findToStringMethod", "Ljava.lang.reflect.Method;", 0x2, NULL },
    { "findFromStringMethodWithIOSClass:withNSString:", "findFromStringMethod", "Ljava.lang.reflect.Method;", 0x2, NULL },
    { "findFromStringConstructorByTypeWithIOSClass:", "findFromStringConstructorByType", "Ljava.lang.reflect.Constructor;", 0x2, NULL },
    { "description", "toString", "Ljava.lang.String;", 0x1, NULL },
  };
  static const J2ObjcFieldInfo fields[] = {
    { "INSTANCE_", NULL, 0x19, "Lorg.joda.convert.StringConvert;", &OrgJodaConvertStringConvert_INSTANCE_,  },
    { "CACHED_NULL_", NULL, 0x1a, "Lorg.joda.convert.TypedStringConverter;", &OrgJodaConvertStringConvert_CACHED_NULL_,  },
    { "factories_", NULL, 0x12, "Ljava.util.concurrent.CopyOnWriteArrayList;", NULL,  },
    { "registered_", NULL, 0x12, "Ljava.util.concurrent.ConcurrentMap;", NULL,  },
  };
  static const J2ObjcClassInfo _OrgJodaConvertStringConvert = { 1, "StringConvert", "org.joda.convert", NULL, 0x11, 23, methods, 4, fields, 0, NULL};
  return &_OrgJodaConvertStringConvert;
}

@end

OrgJodaConvertStringConvert *OrgJodaConvertStringConvert_create() {
  OrgJodaConvertStringConvert_init();
  return [[[OrgJodaConvertStringConvert alloc] initWithBoolean:YES withOrgJodaConvertStringConverterFactoryArray:[IOSObjectArray arrayWithObjects:(id[]){ OrgJodaConvertFactoryNumericArrayStringConverterFactory_get_INSTANCE_(), OrgJodaConvertFactoryNumericObjectArrayStringConverterFactory_get_INSTANCE_(), OrgJodaConvertFactoryCharObjectArrayStringConverterFactory_get_INSTANCE_(), OrgJodaConvertFactoryByteObjectArrayStringConverterFactory_get_INSTANCE_(), OrgJodaConvertFactoryBooleanArrayStringConverterFactory_get_INSTANCE_(), OrgJodaConvertFactoryBooleanObjectArrayStringConverterFactory_get_INSTANCE_() } count:6 type:OrgJodaConvertStringConverterFactory_class_()]] autorelease];
}

void OrgJodaConvertStringConvert_tryRegisterWithNSString_withNSString_(OrgJodaConvertStringConvert *self, NSString *className_, NSString *fromStringMethodName) {
  @try {
    IOSClass *cls = [((JavaLangClassLoader *) nil_chk([[self getClass] getClassLoader])) loadClassWithNSString:className_];
    [self registerMethodsWithIOSClass:cls withNSString:@"toString" withNSString:fromStringMethodName];
  }
  @catch (JavaLangException *ex) {
  }
}

id<OrgJodaConvertTypedStringConverter> OrgJodaConvertStringConvert_findConverterQuietWithIOSClass_(OrgJodaConvertStringConvert *self, IOSClass *cls) {
  if (cls == nil) {
    @throw [[[JavaLangIllegalArgumentException alloc] initWithNSString:@"Class must not be null"] autorelease];
  }
  id<OrgJodaConvertTypedStringConverter> conv = (id<OrgJodaConvertTypedStringConverter>) check_protocol_cast([((id<JavaUtilConcurrentConcurrentMap>) nil_chk(self->registered_)) getWithId:cls], @protocol(OrgJodaConvertTypedStringConverter));
  if (conv == OrgJodaConvertStringConvert_CACHED_NULL_) {
    return nil;
  }
  if (conv == nil) {
    @try {
      conv = OrgJodaConvertStringConvert_findAnyConverterWithIOSClass_(self, cls);
    }
    @catch (JavaLangRuntimeException *ex) {
      [self->registered_ putIfAbsentWithId:cls withId:OrgJodaConvertStringConvert_CACHED_NULL_];
      @throw ex;
    }
    if (conv == nil) {
      [self->registered_ putIfAbsentWithId:cls withId:OrgJodaConvertStringConvert_CACHED_NULL_];
      return nil;
    }
    [self->registered_ putIfAbsentWithId:cls withId:conv];
  }
  return conv;
}

id<OrgJodaConvertTypedStringConverter> OrgJodaConvertStringConvert_findAnyConverterWithIOSClass_(OrgJodaConvertStringConvert *self, IOSClass *cls) {
  id<OrgJodaConvertTypedStringConverter> conv = nil;
  IOSClass *loopCls = [((IOSClass *) nil_chk(cls)) getSuperclass];
  while (loopCls != nil && conv == nil) {
    conv = (id<OrgJodaConvertTypedStringConverter>) check_protocol_cast([((id<JavaUtilConcurrentConcurrentMap>) nil_chk(self->registered_)) getWithId:loopCls], @protocol(OrgJodaConvertTypedStringConverter));
    if (conv != nil && conv != OrgJodaConvertStringConvert_CACHED_NULL_) {
      return conv;
    }
    loopCls = [((IOSClass *) nil_chk(loopCls)) getSuperclass];
  }
  {
    IOSObjectArray *a__ = [cls getInterfaces];
    IOSClass * const *b__ = ((IOSObjectArray *) nil_chk(a__))->buffer_;
    IOSClass * const *e__ = b__ + a__->size_;
    while (b__ < e__) {
      IOSClass *loopIfc = *b__++;
      conv = (id<OrgJodaConvertTypedStringConverter>) check_protocol_cast([((id<JavaUtilConcurrentConcurrentMap>) nil_chk(self->registered_)) getWithId:loopIfc], @protocol(OrgJodaConvertTypedStringConverter));
      if (conv != nil && conv != OrgJodaConvertStringConvert_CACHED_NULL_) {
        return conv;
      }
    }
  }
  for (id<OrgJodaConvertStringConverterFactory> __strong factory in nil_chk(self->factories_)) {
    id<OrgJodaConvertStringConverter> factoryConv = (id<OrgJodaConvertStringConverter>) check_protocol_cast([((id<OrgJodaConvertStringConverterFactory>) nil_chk(factory)) findConverterWithIOSClass:cls], @protocol(OrgJodaConvertStringConverter));
    if (factoryConv != nil) {
      return OrgJodaConvertTypedAdapter_adaptWithIOSClass_withOrgJodaConvertStringConverter_(cls, factoryConv);
    }
  }
  return nil;
}

JavaLangReflectMethod *OrgJodaConvertStringConvert_findToStringMethodWithIOSClass_withNSString_(OrgJodaConvertStringConvert *self, IOSClass *cls, NSString *methodName) {
  JavaLangReflectMethod *m;
  @try {
    m = [((IOSClass *) nil_chk(cls)) getMethod:methodName parameterTypes:[IOSObjectArray arrayWithLength:0 type:IOSClass_class_()]];
  }
  @catch (JavaLangNoSuchMethodException *ex) {
    @throw [[[JavaLangIllegalArgumentException alloc] initWithJavaLangThrowable:ex] autorelease];
  }
  if (JavaLangReflectModifier_isStaticWithInt_([((JavaLangReflectMethod *) nil_chk(m)) getModifiers])) {
    @throw [[[JavaLangIllegalArgumentException alloc] initWithNSString:JreStrcat("$$", @"Method must not be static: ", methodName)] autorelease];
  }
  return m;
}

JavaLangReflectMethod *OrgJodaConvertStringConvert_findFromStringMethodWithIOSClass_withNSString_(OrgJodaConvertStringConvert *self, IOSClass *cls, NSString *methodName) {
  JavaLangReflectMethod *m;
  @try {
    m = [((IOSClass *) nil_chk(cls)) getMethod:methodName parameterTypes:[IOSObjectArray arrayWithObjects:(id[]){ NSString_class_() } count:1 type:IOSClass_class_()]];
  }
  @catch (JavaLangNoSuchMethodException *ex) {
    @try {
      m = [((IOSClass *) nil_chk(cls)) getMethod:methodName parameterTypes:[IOSObjectArray arrayWithObjects:(id[]){ JavaLangCharSequence_class_() } count:1 type:IOSClass_class_()]];
    }
    @catch (JavaLangNoSuchMethodException *ex2) {
      @throw [[[JavaLangIllegalArgumentException alloc] initWithNSString:@"Method not found" withJavaLangThrowable:ex2] autorelease];
    }
  }
  if (JavaLangReflectModifier_isStaticWithInt_([((JavaLangReflectMethod *) nil_chk(m)) getModifiers]) == NO) {
    @throw [[[JavaLangIllegalArgumentException alloc] initWithNSString:JreStrcat("$$", @"Method must be static: ", methodName)] autorelease];
  }
  return m;
}

JavaLangReflectConstructor *OrgJodaConvertStringConvert_findFromStringConstructorByTypeWithIOSClass_(OrgJodaConvertStringConvert *self, IOSClass *cls) {
  @try {
    return [((IOSClass *) nil_chk(cls)) getDeclaredConstructor:[IOSObjectArray arrayWithObjects:(id[]){ NSString_class_() } count:1 type:IOSClass_class_()]];
  }
  @catch (JavaLangNoSuchMethodException *ex) {
    @try {
      return [((IOSClass *) nil_chk(cls)) getDeclaredConstructor:[IOSObjectArray arrayWithObjects:(id[]){ JavaLangCharSequence_class_() } count:1 type:IOSClass_class_()]];
    }
    @catch (JavaLangNoSuchMethodException *ex2) {
      @throw [[[JavaLangIllegalArgumentException alloc] initWithNSString:@"Constructor not found" withJavaLangThrowable:ex2] autorelease];
    }
  }
}

J2OBJC_CLASS_TYPE_LITERAL_SOURCE(OrgJodaConvertStringConvert)

@implementation OrgJodaConvertStringConvert_$1

- (NSString *)convertToStringWithId:(id)object {
  return nil;
}

- (id)convertFromStringWithIOSClass:(IOSClass *)cls
                       withNSString:(NSString *)str {
  return nil;
}

- (IOSClass *)getEffectiveType {
  return nil;
}

- (instancetype)init {
  return [super init];
}

+ (const J2ObjcClassInfo *)__metadata {
  static const J2ObjcMethodInfo methods[] = {
    { "convertToStringWithId:", "convertToString", "Ljava.lang.String;", 0x1, NULL },
    { "convertFromStringWithIOSClass:withNSString:", "convertFromString", "Ljava.lang.Object;", 0x1, NULL },
    { "getEffectiveType", NULL, "Ljava.lang.Class;", 0x1, NULL },
    { "init", NULL, NULL, 0x0, NULL },
  };
  static const J2ObjcClassInfo _OrgJodaConvertStringConvert_$1 = { 1, "$1", "org.joda.convert", "StringConvert", 0x8000, 4, methods, 0, NULL, 0, NULL};
  return &_OrgJodaConvertStringConvert_$1;
}

@end

J2OBJC_CLASS_TYPE_LITERAL_SOURCE(OrgJodaConvertStringConvert_$1)

@implementation OrgJodaConvertStringConvert_$2

- (NSString *)convertToStringWithId:(id)object {
  return [((id<OrgJodaConvertToStringConverter>) nil_chk(val$toString_)) convertToStringWithId:object];
}

- (id)convertFromStringWithIOSClass:(IOSClass *)cls
                       withNSString:(NSString *)str {
  return [((id<OrgJodaConvertFromStringConverter>) nil_chk(val$fromString_)) convertFromStringWithIOSClass:cls withNSString:str];
}

- (IOSClass *)getEffectiveType {
  return val$cls_;
}

- (instancetype)initWithOrgJodaConvertToStringConverter:(id<OrgJodaConvertToStringConverter>)capture$0
                  withOrgJodaConvertFromStringConverter:(id<OrgJodaConvertFromStringConverter>)capture$1
                                           withIOSClass:(IOSClass *)capture$2 {
  OrgJodaConvertStringConvert_$2_set_val$toString_(self, capture$0);
  OrgJodaConvertStringConvert_$2_set_val$fromString_(self, capture$1);
  OrgJodaConvertStringConvert_$2_set_val$cls_(self, capture$2);
  return [super init];
}

- (void)dealloc {
  RELEASE_(val$toString_);
  RELEASE_(val$fromString_);
  RELEASE_(val$cls_);
  [super dealloc];
}

- (void)copyAllFieldsTo:(OrgJodaConvertStringConvert_$2 *)other {
  [super copyAllFieldsTo:other];
  OrgJodaConvertStringConvert_$2_set_val$toString_(other, val$toString_);
  OrgJodaConvertStringConvert_$2_set_val$fromString_(other, val$fromString_);
  OrgJodaConvertStringConvert_$2_set_val$cls_(other, val$cls_);
}

+ (const J2ObjcClassInfo *)__metadata {
  static const J2ObjcMethodInfo methods[] = {
    { "convertToStringWithId:", "convertToString", "Ljava.lang.String;", 0x1, NULL },
    { "convertFromStringWithIOSClass:withNSString:", "convertFromString", "TT;", 0x1, NULL },
    { "getEffectiveType", NULL, "Ljava.lang.Class;", 0x1, NULL },
    { "initWithOrgJodaConvertToStringConverter:withOrgJodaConvertFromStringConverter:withIOSClass:", "init", NULL, 0x0, NULL },
  };
  static const J2ObjcFieldInfo fields[] = {
    { "val$toString_", NULL, 0x1012, "Lorg.joda.convert.ToStringConverter;", NULL,  },
    { "val$fromString_", NULL, 0x1012, "Lorg.joda.convert.FromStringConverter;", NULL,  },
    { "val$cls_", NULL, 0x1012, "Ljava.lang.Class;", NULL,  },
  };
  static const J2ObjcClassInfo _OrgJodaConvertStringConvert_$2 = { 1, "$2", "org.joda.convert", "StringConvert", 0x8000, 4, methods, 3, fields, 0, NULL};
  return &_OrgJodaConvertStringConvert_$2;
}

@end

J2OBJC_CLASS_TYPE_LITERAL_SOURCE(OrgJodaConvertStringConvert_$2)
